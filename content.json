{"meta":{"title":"CodeTrigger","subtitle":"","description":"Know more ,learn more","author":"zj","url":"http://example.com","root":"/"},"pages":[{"title":"tags","date":"2022-10-03T07:14:09.000Z","updated":"2022-10-03T07:15:53.128Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-10-03T03:30:25.000Z","updated":"2022-10-03T04:03:14.057Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"reading","date":"2022-10-03T03:36:21.000Z","updated":"2022-10-03T03:36:21.801Z","comments":true,"path":"reading/index.html","permalink":"http://example.com/reading/index.html","excerpt":"","text":""}],"posts":[{"title":"函数式编程","slug":"函数式编程","date":"2022-10-10T13:44:06.000Z","updated":"2022-10-10T14:05:21.330Z","comments":true,"path":"2022/10/10/函数式编程/","link":"","permalink":"http://example.com/2022/10/10/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","excerpt":"","text":"函数式编程-Stream流 1. 概述 1.1 为什么学？ 能够看懂公司里的代码 大数量下处理集合效率高 代码可读性高 消灭嵌套地狱 12345678910111213141516171819//查询未成年作家的评分在70以上的书籍 由于洋流影响所以作家和书籍可能出现重复，需要进行去重List&lt;Book&gt; bookList = new ArrayList&lt;&gt;();Set&lt;Book&gt; uniqueBookValues = new HashSet&lt;&gt;();Set&lt;Author&gt; uniqueAuthorValues = new HashSet&lt;&gt;();for (Author author : authors) &#123; if (uniqueAuthorValues.add(author)) &#123; if (author.getAge() &lt; 18) &#123; List&lt;Book&gt; books = author.getBooks(); for (Book book : books) &#123; if (book.getScore() &gt; 70) &#123; if (uniqueBookValues.add(book)) &#123; bookList.add(book); &#125; &#125; &#125; &#125; &#125;&#125;System.out.println(bookList); 123456789List&lt;Book&gt; collect = authors.stream() .distinct() .filter(author -&gt; author.getAge() &lt; 18) .map(author -&gt; author.getBooks()) .flatMap(Collection::stream) .filter(book -&gt; book.getScore() &gt; 70) .distinct() .collect(Collectors.toList());System.out.println(collect); 1.2 函数式编程思想 1.2.1 概念 ​ 面向对象思想需要关注用什么对象完成什么事情。而函数式编程思想就类似于我们数学中的函数。它主要关注的是对数据进行了什么操作。 1.2.2 优点 代码简洁，开发快速 接近自然语言，易于理解 易于”并发编程” 2. Lambda表达式 2.1 概述 ​ Lambda是JDK8中一个语法糖。他可以对某些匿名内部类的写法进行简化。它是函数式编程思想的一个重要体现。让我们不用关注是什么对象。而是更关注我们对数据进行了什么操作。 2.2 核心原则 可推导可省略 2. 3 基本格式 1(参数列表)-&gt;&#123;代码&#125; 例一 我们在创建线程并启动时可以使用匿名内部类的写法： 123456new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;你知道吗 我比你想象的 更想在你身边&quot;); &#125;&#125;).start(); 可以使用Lambda的格式对其进行修改。修改后如下： 123new Thread(()-&gt;&#123; System.out.println(&quot;你知道吗 我比你想象的 更想在你身边&quot;);&#125;).start(); 例二: 现有方法定义如下，其中IntBinaryOperator是一个接口。先使用匿名内部类的写法调用该方法。 123456789101112131415public static int calculateNum(IntBinaryOperator operator)&#123; int a = 10; int b = 20; return operator.applyAsInt(a, b);&#125;public static void main(String[] args) &#123; int i = calculateNum(new IntBinaryOperator() &#123; @Override public int applyAsInt(int left, int right) &#123; return left + right; &#125; &#125;); System.out.println(i);&#125; Lambda写法： 123456public static void main(String[] args) &#123; int i = calculateNum((int left, int right)-&gt;&#123; return left + right; &#125;); System.out.println(i);&#125; 例三： 现有方法定义如下，其中IntPredicate是一个接口。先使用匿名内部类的写法调用该方法。 12345678910111213141516public static void printNum(IntPredicate predicate)&#123; int[] arr = &#123;1,2,3,4,5,6,7,8,9,10&#125;; for (int i : arr) &#123; if(predicate.test(i))&#123; System.out.println(i); &#125; &#125;&#125;public static void main(String[] args) &#123; printNum(new IntPredicate() &#123; @Override public boolean test(int value) &#123; return value%2==0; &#125; &#125;);&#125; Lambda写法： 12345678910111213public static void main(String[] args) &#123; printNum((int value)-&gt; &#123; return value%2==0; &#125;);&#125;public static void printNum(IntPredicate predicate)&#123; int[] arr = &#123;1,2,3,4,5,6,7,8,9,10&#125;; for (int i : arr) &#123; if(predicate.test(i))&#123; System.out.println(i); &#125; &#125;&#125; 例四： 现有方法定义如下，其中Function是一个接口。先使用匿名内部类的写法调用该方法。 1234567891011121314public static &lt;R&gt; R typeConver(Function&lt;String,R&gt; function)&#123; String str = &quot;1235&quot;; R result = function.apply(str); return result;&#125;public static void main(String[] args) &#123; Integer result = typeConver(new Function&lt;String, Integer&gt;() &#123; @Override public Integer apply(String s) &#123; return Integer.valueOf(s); &#125; &#125;); System.out.println(result);&#125; Lambda写法： 12345Integer result = typeConver((String s)-&gt;&#123; return Integer.valueOf(s);&#125;);System.out.println(result); 例五： 现有方法定义如下，其中IntConsumer是一个接口。先使用匿名内部类的写法调用该方法。 1234567891011121314public static void foreachArr(IntConsumer consumer)&#123; int[] arr = &#123;1,2,3,4,5,6,7,8,9,10&#125;; for (int i : arr) &#123; consumer.accept(i); &#125;&#125;public static void main(String[] args) &#123; foreachArr(new IntConsumer() &#123; @Override public void accept(int value) &#123; System.out.println(value); &#125; &#125;);&#125; Lambda写法： 12345public static void main(String[] args) &#123; foreachArr((int value)-&gt;&#123; System.out.println(value); &#125;);&#125; 2.4 省略规则 参数类型可以省略 方法体只有一句代码时大括号return和唯一一句代码的分号可以省略 方法只有一个参数时小括号可以省略 以上这些规则都记不住也可以省略不记 3. Stream流 3.1 概述 ​ Java8的Stream使用的是函数式编程模式，如同它的名字一样，它可以被用来对集合或数组进行链状流式的操作。可以更方便的让我们对集合或数组操作。 3.2 案例数据准备 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.16&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 12345678910111213141516@Data@NoArgsConstructor@AllArgsConstructor@EqualsAndHashCode//用于后期的去重使用public class Author &#123; //id private Long id; //姓名 private String name; //年龄 private Integer age; //简介 private String intro; //作品 private List&lt;Book&gt; books;&#125; 1234567891011121314151617181920@Data@AllArgsConstructor@NoArgsConstructor@EqualsAndHashCode//用于后期的去重使用public class Book &#123; //id private Long id; //书名 private String name; //分类 private String category; //评分 private Integer score; //简介 private String intro;&#125; 12345678910111213141516171819202122232425262728293031private static List&lt;Author&gt; getAuthors() &#123; //数据初始化 Author author = new Author(1L,&quot;蒙多&quot;,33,&quot;一个从菜刀中明悟哲理的祖安人&quot;,null); Author author2 = new Author(2L,&quot;亚拉索&quot;,15,&quot;狂风也追逐不上他的思考速度&quot;,null); Author author3 = new Author(3L,&quot;易&quot;,14,&quot;是这个世界在限制他的思维&quot;,null); Author author4 = new Author(3L,&quot;易&quot;,14,&quot;是这个世界在限制他的思维&quot;,null); //书籍列表 List&lt;Book&gt; books1 = new ArrayList&lt;&gt;(); List&lt;Book&gt; books2 = new ArrayList&lt;&gt;(); List&lt;Book&gt; books3 = new ArrayList&lt;&gt;(); books1.add(new Book(1L,&quot;刀的两侧是光明与黑暗&quot;,&quot;哲学,爱情&quot;,88,&quot;用一把刀划分了爱恨&quot;)); books1.add(new Book(2L,&quot;一个人不能死在同一把刀下&quot;,&quot;个人成长,爱情&quot;,99,&quot;讲述如何从失败中明悟真理&quot;)); books2.add(new Book(3L,&quot;那风吹不到的地方&quot;,&quot;哲学&quot;,85,&quot;带你用思维去领略世界的尽头&quot;)); books2.add(new Book(3L,&quot;那风吹不到的地方&quot;,&quot;哲学&quot;,85,&quot;带你用思维去领略世界的尽头&quot;)); books2.add(new Book(4L,&quot;吹或不吹&quot;,&quot;爱情,个人传记&quot;,56,&quot;一个哲学家的恋爱观注定很难把他所在的时代理解&quot;)); books3.add(new Book(5L,&quot;你的剑就是我的剑&quot;,&quot;爱情&quot;,56,&quot;无法想象一个武者能对他的伴侣这么的宽容&quot;)); books3.add(new Book(6L,&quot;风与剑&quot;,&quot;个人传记&quot;,100,&quot;两个哲学家灵魂和肉体的碰撞会激起怎么样的火花呢？&quot;)); books3.add(new Book(6L,&quot;风与剑&quot;,&quot;个人传记&quot;,100,&quot;两个哲学家灵魂和肉体的碰撞会激起怎么样的火花呢？&quot;)); author.setBooks(books1); author2.setBooks(books2); author3.setBooks(books3); author4.setBooks(books3); List&lt;Author&gt; authorList = new ArrayList&lt;&gt;(Arrays.asList(author,author2,author3,author4)); return authorList;&#125; 3.3 快速入门 3.3.1 需求 ​ 我们可以调用getAuthors方法获取到作家的集合。现在需要打印所有年龄小于18的作家的名字，并且要注意去重。 3.3.2 实现 1234567//打印所有年龄小于18的作家的名字，并且要注意去重List&lt;Author&gt; authors = getAuthors();authors. stream()//把集合转换成流 .distinct()//先去除重复的作家 .filter(author -&gt; author.getAge()&lt;18)//筛选年龄小于18的 .forEach(author -&gt; System.out.println(author.getName()));//遍历打印名字 3.4 常用操作 3.4.1 创建流 单列集合： 集合对象.stream() 12 List&lt;Author&gt; authors = getAuthors();Stream&lt;Author&gt; stream = authors.stream(); 数组：Arrays.stream(数组) 或者使用Stream.of来创建 123Integer[] arr = &#123;1,2,3,4,5&#125;;Stream&lt;Integer&gt; stream = Arrays.stream(arr);Stream&lt;Integer&gt; stream2 = Stream.of(arr); 双列集合：转换成单列集合后再创建 123456Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();map.put(&quot;蜡笔小新&quot;,19);map.put(&quot;黑子&quot;,17);map.put(&quot;日向翔阳&quot;,16);Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; stream = map.entrySet().stream(); 3.4.2 中间操作 filter ​ 可以对流中的元素进行条件过滤，符合过滤条件的才能继续留在流中。 例如： ​ 打印所有姓名长度大于1的作家的姓名 1234List&lt;Author&gt; authors = getAuthors();authors.stream() .filter(author -&gt; author.getName().length()&gt;1) .forEach(author -&gt; System.out.println(author.getName())); map ​ 可以把对流中的元素进行计算或转换。 例如： ​ 打印所有作家的姓名 123456List&lt;Author&gt; authors = getAuthors();authors .stream() .map(author -&gt; author.getName()) .forEach(name-&gt;System.out.println(name)); 1234567891011// 打印所有作家的姓名 List&lt;Author&gt; authors = getAuthors();// authors.stream()// .map(author -&gt; author.getName())// .forEach(s -&gt; System.out.println(s)); authors.stream() .map(author -&gt; author.getAge()) .map(age-&gt;age+10) .forEach(age-&gt; System.out.println(age)); distinct ​ 可以去除流中的重复元素。 例如： ​ 打印所有作家的姓名，并且要求其中不能有重复元素。 1234List&lt;Author&gt; authors = getAuthors();authors.stream() .distinct() .forEach(author -&gt; System.out.println(author.getName())); 注意：distinct方法是依赖Object的equals方法来判断是否是相同对象的。所以需要注意重写equals方法。 sorted ​ 可以对流中的元素进行排序。 例如： ​ 对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。 123456 List&lt;Author&gt; authors = getAuthors();// 对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。 authors.stream() .distinct() .sorted() .forEach(author -&gt; System.out.println(author.getAge())); 123456 List&lt;Author&gt; authors = getAuthors();// 对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。 authors.stream() .distinct() .sorted((o1, o2) -&gt; o2.getAge()-o1.getAge()) .forEach(author -&gt; System.out.println(author.getAge())); 注意：如果调用空参的sorted()方法，需要流中的元素是实现了Comparable。 ​ limit ​ 可以设置流的最大长度，超出的部分将被抛弃。 例如： ​ 对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素,然后打印其中年龄最大的两个作家的姓名。 123456List&lt;Author&gt; authors = getAuthors();authors.stream() .distinct() .sorted() .limit(2) .forEach(author -&gt; System.out.println(author.getName())); skip ​ 跳过流中的前n个元素，返回剩下的元素 例如： ​ 打印除了年龄最大的作家外的其他作家，要求不能有重复元素，并且按照年龄降序排序。 1234567// 打印除了年龄最大的作家外的其他作家，要求不能有重复元素，并且按照年龄降序排序。 List&lt;Author&gt; authors = getAuthors(); authors.stream() .distinct() .sorted() .skip(1) .forEach(author -&gt; System.out.println(author.getName())); flatMap ​ map只能把一个对象转换成另一个对象来作为流中的元素。而flatMap可以把一个对象转换成多个对象作为流中的元素。 例一： ​ 打印所有书籍的名字。要求对重复的元素进行去重。 1234567// 打印所有书籍的名字。要求对重复的元素进行去重。 List&lt;Author&gt; authors = getAuthors(); authors.stream() .flatMap(author -&gt; author.getBooks().stream()) .distinct() .forEach(book -&gt; System.out.println(book.getName())); 例二： ​ 打印现有数据的所有分类。要求对分类进行去重。不能出现这种格式：哲学,爱情 12345678// 打印现有数据的所有分类。要求对分类进行去重。不能出现这种格式：哲学,爱情 爱情 List&lt;Author&gt; authors = getAuthors(); authors.stream() .flatMap(author -&gt; author.getBooks().stream()) .distinct() .flatMap(book -&gt; Arrays.stream(book.getCategory().split(&quot;,&quot;))) .distinct() .forEach(category-&gt; System.out.println(category)); 3.4.3 终结操作 forEach ​ 对流中的元素进行遍历操作，我们通过传入的参数去指定对遍历到的元素进行什么具体操作。 例子： ​ 输出所有作家的名字 12345678// 输出所有作家的名字 List&lt;Author&gt; authors = getAuthors(); authors.stream() .map(author -&gt; author.getName()) .distinct() .forEach(name-&gt; System.out.println(name)); count ​ 可以用来获取当前流中元素的个数。 例子： ​ 打印这些作家的所出书籍的数目，注意删除重复元素。 12345678// 打印这些作家的所出书籍的数目，注意删除重复元素。 List&lt;Author&gt; authors = getAuthors(); long count = authors.stream() .flatMap(author -&gt; author.getBooks().stream()) .distinct() .count(); System.out.println(count); max&amp;min ​ 可以用来或者流中的最值。 例子： ​ 分别获取这些作家的所出书籍的最高分和最低分并打印。 123456789101112131415// 分别获取这些作家的所出书籍的最高分和最低分并打印。 //Stream&lt;Author&gt; -&gt; Stream&lt;Book&gt; -&gt;Stream&lt;Integer&gt; -&gt;求值 List&lt;Author&gt; authors = getAuthors(); Optional&lt;Integer&gt; max = authors.stream() .flatMap(author -&gt; author.getBooks().stream()) .map(book -&gt; book.getScore()) .max((score1, score2) -&gt; score1 - score2); Optional&lt;Integer&gt; min = authors.stream() .flatMap(author -&gt; author.getBooks().stream()) .map(book -&gt; book.getScore()) .min((score1, score2) -&gt; score1 - score2); System.out.println(max.get()); System.out.println(min.get()); collect ​ 把当前流转换成一个集合。 例子： ​ 获取一个存放所有作者名字的List集合。 123456// 获取一个存放所有作者名字的List集合。 List&lt;Author&gt; authors = getAuthors(); List&lt;String&gt; nameList = authors.stream() .map(author -&gt; author.getName()) .collect(Collectors.toList()); System.out.println(nameList); ​ 获取一个所有书名的Set集合。 1234567// 获取一个所有书名的Set集合。 List&lt;Author&gt; authors = getAuthors(); Set&lt;Book&gt; books = authors.stream() .flatMap(author -&gt; author.getBooks().stream()) .collect(Collectors.toSet()); System.out.println(books); ​ 获取一个Map集合，map的key为作者名，value为List 12345678// 获取一个Map集合，map的key为作者名，value为List&lt;Book&gt; List&lt;Author&gt; authors = getAuthors(); Map&lt;String, List&lt;Book&gt;&gt; map = authors.stream() .distinct() .collect(Collectors.toMap(author -&gt; author.getName(), author -&gt; author.getBooks())); System.out.println(map); 查找与匹配 anyMatch ​ 可以用来判断是否有任意符合匹配条件的元素，结果为boolean类型。 例子： ​ 判断是否有年龄在29以上的作家 12345// 判断是否有年龄在29以上的作家 List&lt;Author&gt; authors = getAuthors(); boolean flag = authors.stream() .anyMatch(author -&gt; author.getAge() &gt; 29); System.out.println(flag); allMatch ​ 可以用来判断是否都符合匹配条件，结果为boolean类型。如果都符合结果为true，否则结果为false。 例子： ​ 判断是否所有的作家都是成年人 12345// 判断是否所有的作家都是成年人 List&lt;Author&gt; authors = getAuthors(); boolean flag = authors.stream() .allMatch(author -&gt; author.getAge() &gt;= 18); System.out.println(flag); noneMatch ​ 可以判断流中的元素是否都不符合匹配条件。如果都不符合结果为true，否则结果为false 例子： ​ 判断作家是否都没有超过100岁的。 1234567// 判断作家是否都没有超过100岁的。 List&lt;Author&gt; authors = getAuthors(); boolean b = authors.stream() .noneMatch(author -&gt; author.getAge() &gt; 100); System.out.println(b); findAny ​ 获取流中的任意一个元素。该方法没有办法保证获取的一定是流中的第一个元素。 例子： ​ 获取任意一个年龄大于18的作家，如果存在就输出他的名字 1234567// 获取任意一个年龄大于18的作家，如果存在就输出他的名字 List&lt;Author&gt; authors = getAuthors(); Optional&lt;Author&gt; optionalAuthor = authors.stream() .filter(author -&gt; author.getAge()&gt;18) .findAny(); optionalAuthor.ifPresent(author -&gt; System.out.println(author.getName())); findFirst ​ 获取流中的第一个元素。 例子： ​ 获取一个年龄最小的作家，并输出他的姓名。 1234567// 获取一个年龄最小的作家，并输出他的姓名。 List&lt;Author&gt; authors = getAuthors(); Optional&lt;Author&gt; first = authors.stream() .sorted((o1, o2) -&gt; o1.getAge() - o2.getAge()) .findFirst(); first.ifPresent(author -&gt; System.out.println(author.getName())); reduce归并 ​ 对流中的数据按照你指定的计算方式计算出一个结果。（缩减操作） ​ reduce的作用是把stream中的元素给组合起来，我们可以传入一个初始值，它会按照我们的计算方式依次拿流中的元素和初始化值进行计算，计算结果再和后面的元素计算。 ​ reduce两个参数的重载形式内部的计算方式如下： 1234T result = identity;for (T element : this stream) result = accumulator.apply(result, element)return result; ​ 其中identity就是我们可以通过方法参数传入的初始值，accumulator的apply具体进行什么计算也是我们通过方法参数来确定的。 例子： ​ 使用reduce求所有作者年龄的和 1234567// 使用reduce求所有作者年龄的和 List&lt;Author&gt; authors = getAuthors(); Integer sum = authors.stream() .distinct() .map(author -&gt; author.getAge()) .reduce(0, (result, element) -&gt; result + element); System.out.println(sum); ​ 使用reduce求所有作者中年龄的最大值 1234567// 使用reduce求所有作者中年龄的最大值 List&lt;Author&gt; authors = getAuthors(); Integer max = authors.stream() .map(author -&gt; author.getAge()) .reduce(Integer.MIN_VALUE, (result, element) -&gt; result &lt; element ? element : result); System.out.println(max); ​ 使用reduce求所有作者中年龄的最小值 123456// 使用reduce求所有作者中年龄的最小值 List&lt;Author&gt; authors = getAuthors(); Integer min = authors.stream() .map(author -&gt; author.getAge()) .reduce(Integer.MAX_VALUE, (result, element) -&gt; result &gt; element ? element : result); System.out.println(min); ​ reduce一个参数的重载形式内部的计算 1234567891011boolean foundAny = false; T result = null; for (T element : this stream) &#123; if (!foundAny) &#123; foundAny = true; result = element; &#125; else result = accumulator.apply(result, element); &#125; return foundAny ? Optional.of(result) : Optional.empty(); ​ 如果用一个参数的重载方法去求最小值代码如下： 123456// 使用reduce求所有作者中年龄的最小值List&lt;Author&gt; authors = getAuthors();Optional&lt;Integer&gt; minOptional = authors.stream() .map(author -&gt; author.getAge()) .reduce((result, element) -&gt; result &gt; element ? element : result);minOptional.ifPresent(age-&gt; System.out.println(age)); 3.5 注意事项 惰性求值（如果没有终结操作，没有中间操作是不会得到执行的） 流是一次性的（一旦一个流对象经过一个终结操作后。这个流就不能再被使用） 不会影响原数据（我们在流中可以多数据做很多处理。但是正常情况下是不会影响原来集合中的元素的。这往往也是我们期望的） 4. Optional 4.1 概述 ​ 我们在编写代码的时候出现最多的就是空指针异常。所以在很多情况下我们需要做各种非空的判断。 ​ 例如： 1234Author author = getAuthor();if(author!=null)&#123; System.out.println(author.getName());&#125; ​ 尤其是对象中的属性还是一个对象的情况下。这种判断会更多。 ​ 而过多的判断语句会让我们的代码显得臃肿不堪。 ​ 所以在JDK8中引入了Optional,养成使用Optional的习惯后你可以写出更优雅的代码来避免空指针异常。 ​ 并且在很多函数式编程相关的API中也都用到了Optional，如果不会使用Optional也会对函数式编程的学习造成影响。 4.2 使用 4.2.1 创建对象 ​ Optional就好像是包装类，可以把我们的具体数据封装Optional对象内部。然后我们去使用Optional中封装好的方法操作封装进去的数据就可以非常优雅的避免空指针异常。 ​ 我们一般使用Optional的静态方法ofNullable来把数据封装成一个Optional对象。无论传入的参数是否为null都不会出现问题。 12Author author = getAuthor();Optional&lt;Author&gt; authorOptional = Optional.ofNullable(author); ​ 你可能会觉得还要加一行代码来封装数据比较麻烦。但是如果改造下getAuthor方法，让其的返回值就是封装好的Optional的话，我们在使用时就会方便很多。 ​ 而且在实际开发中我们的数据很多是从数据库获取的。Mybatis从3.5版本可以也已经支持Optional了。我们可以直接把dao方法的返回值类型定义成Optional类型，MyBastis会自己把数据封装成Optional对象返回。封装的过程也不需要我们自己操作。 ​ 如果你确定一个对象不是空的则可以使用Optional的静态方法of来把数据封装成Optional对象。 12Author author = new Author();Optional&lt;Author&gt; authorOptional = Optional.of(author); ​ 但是一定要注意，如果使用of的时候传入的参数必须不为null。（尝试下传入null会出现什么结果） ​ 如果一个方法的返回值类型是Optional类型。而如果我们经判断发现某次计算得到的返回值为null，这个时候就需要把null封装成Optional对象返回。这时则可以使用Optional的静态方法empty来进行封装。 1Optional.empty() ​ ​ 所以最后你觉得哪种方式会更方便呢？ofNullable 4.2.2 安全消费值 ​ 我们获取到一个Optional对象后肯定需要对其中的数据进行使用。这时候我们可以使用其ifPresent方法对来消费其中的值。 ​ 这个方法会判断其内封装的数据是否为空，不为空时才会执行具体的消费代码。这样使用起来就更加安全了。 ​ 例如,以下写法就优雅的避免了空指针异常。 123Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());authorOptional.ifPresent(author -&gt; System.out.println(author.getName())); 4.2.3 获取值 ​ 如果我们想获取值自己进行处理可以使用get方法获取，但是不推荐。因为当Optional内部的数据为空的时候会出现异常。 4.2.4 安全获取值 ​ 如果我们期望安全的获取值。我们不推荐使用get方法，而是使用Optional提供的以下方法。 orElseGet 获取数据并且设置数据为空时的默认值。如果数据不为空就能获取到该数据。如果为空则根据你传入的参数来创建对象作为默认值返回。 12Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());Author author1 = authorOptional.orElseGet(() -&gt; new Author()); orElseThrow 获取数据，如果数据不为空就能获取到该数据。如果为空则根据你传入的参数来创建异常抛出。 1234567Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());try &#123; Author author = authorOptional.orElseThrow((Supplier&lt;Throwable&gt;) () -&gt; new RuntimeException(&quot;author为空&quot;)); System.out.println(author.getName());&#125; catch (Throwable throwable) &#123; throwable.printStackTrace();&#125; 4.2.5 过滤 ​ 我们可以使用filter方法对数据进行过滤。如果原本是有数据的，但是不符合判断，也会变成一个无数据的Optional对象。 123Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());authorOptional.filter(author -&gt; author.getAge()&gt;100).ifPresent(author -&gt; System.out.println(author.getName())); 4.2.6 判断 ​ 我们可以使用isPresent方法进行是否存在数据的判断。如果为空返回值为false,如果不为空，返回值为true。但是这种方式并不能体现Optional的好处，更推荐使用ifPresent方法。 12345Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());if (authorOptional.isPresent()) &#123; System.out.println(authorOptional.get().getName());&#125; 4.2.7 数据转换 ​ Optional还提供了map可以让我们的对数据进行转换，并且转换得到的数据也还是被Optional包装好的，保证了我们的使用安全。 例如我们想获取作家的书籍集合。 12345private static void testMap() &#123; Optional&lt;Author&gt; authorOptional = getAuthorOptional(); Optional&lt;List&lt;Book&gt;&gt; optionalBooks = authorOptional.map(author -&gt; author.getBooks()); optionalBooks.ifPresent(books -&gt; System.out.println(books));&#125; 5. 函数式接口 5.1 概述 ​ 只有一个抽象方法的接口我们称之为函数接口。 ​ JDK的函数式接口都加上了**@FunctionalInterface** 注解进行标识。但是无论是否加上该注解只要接口中只有一个抽象方法，都是函数式接口。 5.2 常见函数式接口 ​ Consumer 消费接口 根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中对传入的参数进行消费。 ​ Function 计算转换接口 根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中对传入的参数计算或转换，把结果返回 ​ Predicate 判断接口 根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中对传入的参数条件判断，返回判断结果 ​ Supplier 生产型接口 根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中创建对象，把创建好的对象返回 5.3 常用的默认方法 and 我们在使用Predicate接口时候可能需要进行判断条件的拼接。而and方法相当于是使用&amp;&amp;来拼接两个判断条件 例如： 打印作家中年龄大于17并且姓名的长度大于1的作家。 12345678910111213List&lt;Author&gt; authors = getAuthors();Stream&lt;Author&gt; authorStream = authors.stream();authorStream.filter(new Predicate&lt;Author&gt;() &#123; @Override public boolean test(Author author) &#123; return author.getAge()&gt;17; &#125;&#125;.and(new Predicate&lt;Author&gt;() &#123; @Override public boolean test(Author author) &#123; return author.getName().length()&gt;1; &#125;&#125;)).forEach(author -&gt; System.out.println(author)); or 我们在使用Predicate接口时候可能需要进行判断条件的拼接。而or方法相当于是使用||来拼接两个判断条件。 例如： 打印作家中年龄大于17或者姓名的长度小于2的作家。 1234567891011121314// 打印作家中年龄大于17或者姓名的长度小于2的作家。 List&lt;Author&gt; authors = getAuthors(); authors.stream() .filter(new Predicate&lt;Author&gt;() &#123; @Override public boolean test(Author author) &#123; return author.getAge()&gt;17; &#125; &#125;.or(new Predicate&lt;Author&gt;() &#123; @Override public boolean test(Author author) &#123; return author.getName().length()&lt;2; &#125; &#125;)).forEach(author -&gt; System.out.println(author.getName())); negate Predicate接口中的方法。negate方法相当于是在判断添加前面加了个! 表示取反 例如： 打印作家中年龄不大于17的作家。 123456789// 打印作家中年龄不大于17的作家。 List&lt;Author&gt; authors = getAuthors(); authors.stream() .filter(new Predicate&lt;Author&gt;() &#123; @Override public boolean test(Author author) &#123; return author.getAge()&gt;17; &#125; &#125;.negate()).forEach(author -&gt; System.out.println(author.getAge())); 6. 方法引用 ​ 我们在使用lambda时，如果方法体中只有一个方法的调用的话（包括构造方法）,我们可以用方法引用进一步简化代码。 6.1 推荐用法 ​ 我们在使用lambda时不需要考虑什么时候用方法引用，用哪种方法引用，方法引用的格式是什么。我们只需要在写完lambda方法发现方法体只有一行代码，并且是方法的调用时使用快捷键尝试是否能够转换成方法引用即可。 ​ 当我们方法引用使用的多了慢慢的也可以直接写出方法引用。 6.2 基本格式 ​ 类名或者对象名::方法名 6.3 语法详解(了解) 6.3.1 引用类的静态方法 ​ 其实就是引用类的静态方法 格式 1类名::方法名 使用前提 ​ 如果我们在重写方法的时候，方法体中只有一行代码，并且这行代码是调用了某个类的静态方法，并且我们把要重写的抽象方法中所有的参数都按照顺序传入了这个静态方法中，这个时候我们就可以引用类的静态方法。 ​ 例如： 如下代码就可以用方法引用进行简化 123456List&lt;Author&gt; authors = getAuthors();Stream&lt;Author&gt; authorStream = authors.stream();authorStream.map(author -&gt; author.getAge()) .map(age-&gt;String.valueOf(age)); 注意，如果我们所重写的方法是没有参数的，调用的方法也是没有参数的也相当于符合以上规则。 优化后如下： 123456List&lt;Author&gt; authors = getAuthors();Stream&lt;Author&gt; authorStream = authors.stream();authorStream.map(author -&gt; author.getAge()) .map(String::valueOf); 6.3.2 引用对象的实例方法 格式 1对象名::方法名 使用前提 ​ 如果我们在重写方法的时候，方法体中只有一行代码，并且这行代码是调用了某个对象的成员方法，并且我们把要重写的抽象方法中所有的参数都按照顺序传入了这个成员方法中，这个时候我们就可以引用对象的实例方法 例如： 123456List&lt;Author&gt; authors = getAuthors();Stream&lt;Author&gt; authorStream = authors.stream();StringBuilder sb = new StringBuilder();authorStream.map(author -&gt; author.getName()) .forEach(name-&gt;sb.append(name)); 优化后： 123456List&lt;Author&gt; authors = getAuthors();Stream&lt;Author&gt; authorStream = authors.stream();StringBuilder sb = new StringBuilder();authorStream.map(author -&gt; author.getName()) .forEach(sb::append); 6.3.4 引用类的实例方法 格式 1类名::方法名 使用前提 ​ 如果我们在重写方法的时候，方法体中只有一行代码，并且这行代码是调用了第一个参数的成员方法，并且我们把要重写的抽象方法中剩余的所有的参数都按照顺序传入了这个成员方法中，这个时候我们就可以引用类的实例方法。 例如： 12345678910111213141516171819 interface UseString&#123; String use(String str,int start,int length); &#125; public static String subAuthorName(String str, UseString useString)&#123; int start = 0; int length = 1; return useString.use(str,start,length); &#125; public static void main(String[] args) &#123; subAuthorName(&quot;三更草堂&quot;, new UseString() &#123; @Override public String use(String str, int start, int length) &#123; return str.substring(start,length); &#125; &#125;);&#125; 优化后如下： 12345public static void main(String[] args) &#123; subAuthorName(&quot;三更草堂&quot;, String::substring);&#125; 6.3.5 构造器引用 ​ 如果方法体中的一行代码是构造器的话就可以使用构造器引用。 格式 1类名::new 使用前提 ​ 如果我们在重写方法的时候，方法体中只有一行代码，并且这行代码是调用了某个类的构造方法，并且我们把要重写的抽象方法中的所有的参数都按照顺序传入了这个构造方法中，这个时候我们就可以引用构造器。 例如： 123456List&lt;Author&gt; authors = getAuthors();authors.stream() .map(author -&gt; author.getName()) .map(name-&gt;new StringBuilder(name)) .map(sb-&gt;sb.append(&quot;-三更&quot;).toString()) .forEach(str-&gt; System.out.println(str)); 优化后： 123456List&lt;Author&gt; authors = getAuthors();authors.stream() .map(author -&gt; author.getName()) .map(StringBuilder::new) .map(sb-&gt;sb.append(&quot;-三更&quot;).toString()) .forEach(str-&gt; System.out.println(str)); 7. 高级用法 基本数据类型优化 ​ 我们之前用到的很多Stream的方法由于都使用了泛型。所以涉及到的参数和返回值都是引用数据类型。 ​ 即使我们操作的是整数小数，但是实际用的都是他们的包装类。JDK5中引入的自动装箱和自动拆箱让我们在使用对应的包装类时就好像使用基本数据类型一样方便。但是你一定要知道装箱和拆箱肯定是要消耗时间的。虽然这个时间消耗很下。但是在大量的数据不断的重复装箱拆箱的时候，你就不能无视这个时间损耗了。 ​ 所以为了让我们能够对这部分的时间消耗进行优化。Stream还提供了很多专门针对基本数据类型的方法。 ​ 例如：mapToInt,mapToLong,mapToDouble,flatMapToInt,flatMapToDouble等。 1234567891011121314151617private static void test27() &#123; List&lt;Author&gt; authors = getAuthors(); authors.stream() .map(author -&gt; author.getAge()) .map(age -&gt; age + 10) .filter(age-&gt;age&gt;18) .map(age-&gt;age+2) .forEach(System.out::println); authors.stream() .mapToInt(author -&gt; author.getAge()) .map(age -&gt; age + 10) .filter(age-&gt;age&gt;18) .map(age-&gt;age+2) .forEach(System.out::println);&#125; 并行流 ​ 当流中有大量元素时，我们可以使用并行流去提高操作的效率。其实并行流就是把任务分配给多个线程去完全。如果我们自己去用代码实现的话其实会非常的复杂，并且要求你对并发编程有足够的理解和认识。而如果我们使用Stream的话，我们只需要修改一个方法的调用就可以使用并行流来帮我们实现，从而提高效率。 ​ parallel方法可以把串行流转换成并行流。 1234567891011121314private static void test28() &#123; Stream&lt;Integer&gt; stream = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); Integer sum = stream.parallel() .peek(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer num) &#123; System.out.println(num+Thread.currentThread().getName()); &#125; &#125;) .filter(num -&gt; num &gt; 5) .reduce((result, ele) -&gt; result + ele) .get(); System.out.println(sum);&#125; ​ 也可以通过parallelStream直接获取并行流对象。 1234567List&lt;Author&gt; authors = getAuthors();authors.parallelStream() .map(author -&gt; author.getAge()) .map(age -&gt; age + 10) .filter(age-&gt;age&gt;18) .map(age-&gt;age+2) .forEach(System.out::println);","categories":[],"tags":[{"name":"Java8","slug":"Java8","permalink":"http://example.com/tags/Java8/"}]},{"title":"一文详解在线人数统计","slug":"一文详解在线人数统计","date":"2022-10-09T07:09:06.000Z","updated":"2022-10-09T07:26:01.277Z","comments":true,"path":"2022/10/09/一文详解在线人数统计/","link":"","permalink":"http://example.com/2022/10/09/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E5%9C%A8%E7%BA%BF%E4%BA%BA%E6%95%B0%E7%BB%9F%E8%AE%A1/","excerpt":"在线人数的统计","text":"在线人数的统计 使用场景 在视频场景下，经常可以看到当前有多少人在看，或者某些场景下，需要我们计算直播间的瞬时人数，作为后端人员，sql编写是必须的，但是这种场景的sql在怎么编写呢？ 要实现动态计算访客，可以给sql打一个数据标签，进入（访问）时记录为1，退出时记录为-1。 实现步骤 1、取用户进入直播间时为1，退出为-1。 这里贴上nowCode原题目 https://www.nowcoder.com/practice/d69677e41f9a4bf3b3ed7a42573e9490 12345678910111213141516select course_id, user_id, in_datetime dt, 1 uvfrom attend_tbunion allselect course_id, user_id, out_datetime dt, -1 uvfrom attend_tb)t1 这样可以计算到每个进入或出去的记录的值，方便后面进行计算 2、使用窗口函数进行计算 关于窗口函数，不熟悉的可以前去这个知乎er解析里面看，讲解的十分清晰。 通俗易懂的学会：SQL窗口函数 - 知乎 (zhihu.com) 1sum(uv) over(partition by course_id order by dt,uv desc) uv_cnt 关键点：按照日期排序，就可以得到每个时间瞬时进入或出去的人数，使用sum(uv)则可以计算瞬时值，因为需要计算每个课程的瞬时值，所以需要按照课程的id进行分组，这个分组的好处是，不是聚合分组，不会减少行的数量。 3、 最后计算最大值即可 贴上完整sql代码 1234567891011121314151617181920212223242526272829select course_id,course_name,max(uv_cnt) max_numfrom (select a.course_id,course_name,sum(uv) over(partition by course_id order by dt,uv desc) uv_cntfrom (select course_id, user_id, in_datetime dt, 1 uvfrom attend_tbunion allselect course_id, user_id, out_datetime dt, -1 uvfrom attend_tb)t1 join course_tb a on t1.course_id=a.course_id)t2group by course_id,course_name order by course_id","categories":[],"tags":[{"name":"MySql","slug":"MySql","permalink":"http://example.com/tags/MySql/"}]},{"title":"Vue.js入门到入土","slug":"Vue-js入门到入土","date":"2022-10-03T06:49:37.000Z","updated":"2022-10-07T14:24:54.883Z","comments":true,"path":"2022/10/03/Vue-js入门到入土/","link":"","permalink":"http://example.com/2022/10/03/Vue-js%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/","excerpt":"Vue学习之旅","text":"Vue学习之旅 webpack 前端模块化，解决js兼容问题，项目打包等都需要webpack使用node创建前端工程 -D参数 在开发阶段使用的包 -S参数 在开发上线都需要的包 webpack配置文件编写： 123module.exports=&#123; //开发环境 development | production mode:&#x27;development&#x27;&#125; 在package.json文件的scripts脚本加入(可以使用npm运行的脚本) &quot;dev&quot; :&quot;webpack&quot; npm run dev 后会发现一个dist文件夹，引入dist&#x2F;main.js文件，即可 两种模式的区别 12development 开发环境使用，打包速度快production 上线的时候用，打包慢，但是压缩的文件更小 默认约定和改变 打包目录：.&#x2F;src&#x2F;index.js 输出路径 .&#x2F;dist&#x2F;main.js 123//指定处理的文件 entry: path.join(__dirname,&#x27;./src/index.js&#x27;),output:&#123; path:, filename: &#125; 安装配置webpack插件 npm install &#x77;&#x65;&#98;&#x70;&#x61;&#x63;&#107;&#45;&#100;&#101;&#x76;&#45;&#x73;&#x65;&#114;&#x76;&#x65;&#114;&#64;&#51;&#x2e;&#x31;&#x31;&#x2e;&#x32; -D 更改配置文件“scripts” :”dev serve “ 重新run发现报错更改webpack-cli版本为4.10.0 安装了webpack-dev-server后，生成的js文件是在内存中的，需要手动引入 html-webpack-plugin 配置完成不用手动进入src的index页面，打开8080就是首页 12345678//导入HTML插件 const HtmlPlugin=require(&#x27;html-webpack-plugin&#x27;);const htmlPlugin=new HtmlPlugin(&#123; template:&#x27;./src/index.html&#x27;, //指定原文件存放路径 filename:&#x27;./index.html&#x27; //指定生成文件的存放路径 &#125;) module.exports=&#123; mode:&#x27;development&#x27;, plugins :[htmlPlugin] //通过节点使插件生效 &#125; 引入这个插件不需要再手动引入打包过的js文件 devServer节点 设置默认打开浏览器 123456`devServer:&#123; open:true, //是否打开浏览器 host:&#x27;127.0.0.1&#x27;, //主机地址 port: 80 //端口号 &#125;` loader 加载css等文件注意： 如果报错loader找不到先安装 1npm install style-loader css-loader 配置文件 12345678module:&#123; rules:[ &#123;test:/\\.css$/,use:[&#123; loader: &#x27;style-loader&#x27; &#125;, &#123; loader: &#x27;css-loader&#x27; &#125;]&#125;， ] &#125; 打包处理less文件 安装loadernpm i &#108;&#101;&#x73;&#x73;&#x2d;&#108;&#x6f;&#x61;&#100;&#101;&#114;&#64;&#x31;&#x30;&#x2e;&#48;&#46;&#49; &#108;&#101;&#x73;&#115;&#x40;&#x34;&#x2e;&#x31;&#x2e;&#x31; -D 更改配置文件 图片loader加载需要安装url-loader file-loader 1234npm i url-loader@4.1.1 file-loader@6.2.0 -D配置文件&#123;test:/\\.gif|jpg|png$/,user:[&#123;loader:&#x27;url-loader|limit=22229&#x27;&#125;]&#125; 配置build命令 1&quot;build&quot; &quot;webpack --mode production&quot; sourceMap 记录源代码代码的位置信息，以及打包的代码的位置信息更改配置文件中devtool的值即可在调试中输出准确的代码位置 Vue 特点 双向绑定：不操作DOM的前提下，自动把用户填写的数据同步到数据源 数据驱动视图：页面监听数据，数据发生改变重新渲染页面 MVVM架构 Model：数据源 View：当前页面所渲染的DOM结构 ViewModel ：vue实例 使用步骤 1、导入vue.js脚本文件 12345678910111213141516171819```&lt;script src=&quot; https://cdn.staticfile.org/vue/2.6.12/vue.min.js&quot;&gt;&lt;/script&gt;`页面中声明一个被vue控制的DOM区域`&lt;div id=&quot;app&quot;&gt;&#123;&#123; message &#125;&#125;`创建vm实例对象``` vueconst vm=new Vue(&#123; el:&#x27;#app&#x27;, //控制区域 data:&#123; //数据源 message:&#x27;李四&#x27;, list:[&#x27;1&#x27;,&#x27;2&#x27;], &#125; &#125;); 内容渲染指令 v-text 渲染值到标签中，但是会覆盖原有内容 插值表达式 作用同上，但是不会覆盖原来的内容 v-html 渲染文本和HTML标签 属性绑定指令 123456注意：插值表达式不能用在属性节点中，只能用在内容节点&lt;input type=&quot;text&quot; v-bind:placeholder=&quot;tips&quot;&gt;使用v-bind可以动态绑定属性，给那个属性绑定，就在哪个属性前面加上v-bind:，可以简写为：，例如:src插值表达式和v-bind可以进行简单运算&lt;div&gt;&#123;&#123;msg.split(&#x27;&#x27;).reverse()&#125;&#125;&lt;/div&gt; 事件绑定 vue提供了v-on指令进行事件绑定 1&lt;button v-on:click=&quot;add&quot;&gt;+1&lt;/button&gt; //:后面声明事件的类型 并且vue提供methods对象允许我们定义js方法 1234567891011 methods:&#123; add:function()&#123; console.log(&#x27;ok&#x27;); this.count++; &#125; &#125;//简写add()&#123; this.count++; &#125; 通过this访问数据源中的对象 因为this指向的是Vue对象，可以使用this代替vue实例访问数据源中的值 简写以及传参 1&lt;button @click=&quot;add(1)&quot;&gt;+1&lt;/button&gt; $event事件绑定 1234567//事件没有传递参数，则会有一个默认事件对象 add(e)&#123; this.count++; console.log(e); console.log(e.target); &#125;======控制台打印如下结果 但是如果方法传递了参数，就会覆盖这个事件对象可以通过vue内置对象，$event传入事件对象 事件修饰符 原生js中，我们可以通过事件的方法阻止事件默认行为和事件冒泡。在vue中提供的更加方便的实现:事件修饰符 12@click.prevent //.prevent就可以阻止默认行为 按键修饰符 12&lt;input type=&quot;text&quot; @keyup.enter=&quot;append&quot; placeholder=&quot;请输入&quot;&gt; 双向绑定 双向数据绑定，vue提供v-model进行数据绑定，通过这个指令，用户在视图上面对数据的修改，可以被数据源感知到并更新，从而不用操作DOM。 v-bind:单向数据绑定，数据源改变会导致页面数据改变，但是反过来却不会 表单元素才能使用v-model指令，例如input,select,textareav-model修饰符 v-model会自动判断需要双向绑定的值，radio绑定的是checked属性，text则绑定value属性 条件渲染 vue提供条件渲染v-if和v-show进行动态控制组件的展示 v-if 动态移除元素或者创建元素 v-show 添加和移除display:none元素 v-else搭配v-if使用 列表渲染 vue提供v-for进行对列表的渲染，渲染到哪个元素给那个元素添加v-for格式形如 1&lt;tr v-for=&quot;index in list&quot;&gt; 另外，v-for提供了一个可选参数，返回当前的索引 123456&lt;tr v-for=&quot;(item,index) in list&quot;&gt;&lt;td&gt;&#123;&#123;index&#125;&#125;&lt;/td&gt;&lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt;&lt;td&gt;&#123;&#123;item.age&#125;&#125;&lt;/td&gt;&lt;td&gt;&#123;&#123;item.sex&#125;&#125;&lt;/td&gt;&lt;/tr&gt; 官方推荐使用v-for绑定一个key值，为每个对象的item值 1&lt;tr v-for=&quot;(item,index) in list&quot; :key=&quot;item.id&quot;&gt; 复习js删除 filter函数接受一个回调函数，返回的是过滤的条件 1this.list=this.list.filter(item =&gt; return item.id !== id) 过滤器 只能在vue2.0中使用，常用于文本格式化 12345filters:&#123; format(val)&#123; return new Date(val); &#125;&#125; 调用 1&#123;&#123;val | format(val)&#125;&#125; 全局过滤器 123Vue.filter(&#x27;过滤器名&#x27;, ()=&gt;&#123; 回调函数&#125;) 使用过滤器全局格式化日期 可以使用dayjs插件快速格式化时间 注意这个过滤器要放在vue实例之前，否则不会生效 123456789//定义全局过滤器，格式化时间 Vue.filter(&#x27;dateformat&#x27;,(time)=&gt;&#123; //yyyy-MM-dd的日期格式 //使用dayjs格式化时间 const dstr= dayjs(time).format(&#x27;YYYY-MM-DD&#x27;); console.log(dstr); return dstr; &#125;); 侦听器 监听数据的变化 123456watch:&#123; //监视谁，就把谁作为侦听器名字 username(newVal,oldVal)&#123; &#125;&#125; 对象形式的监听器 1234567891011watch:&#123; username:&#123; handler(newVal,oldVal)&#123; &#125;, //是否立即触发 immediate:true， //深度监听 deep:true &#125;&#125; 计算属性 12345computed:&#123; rgba()&#123; &#125;&#125; axios 用于发送网络请求 123456789axios(&#123; method:&#x27;&#x27;, url:&#x27;&#x27;， //get参数 ？username=&#x27;&#x27; params:&#123; &#125;, //请求体参数， data:&#123;&#125;,&#125;).then((response)=&gt;&#123;&#125;) //返回的是一个promise对象，可以调用then继续操作 response 对象中的data属性才是服务端返回的值方法返回promise,可以使用await修饰， 但是方法需要是async,async方法返回的是一个promise对象 123456789const data= await axios(&#123; method:&#x27;get&#x27;, //get参数 ？username=&#x27;&#x27; params:&#123; &#125;, //请求体参数 data:&#123;&#125;, url:&#x27;https://www.escook.cn/api/finduser/&#x27;+&#x27;admin&#x27; &#125;) get 1234567891011axios.get(&#x27;url&#x27;,&#123; params:&#123;&#125;,&#125;)//具体事例 //axios get 和post axios.get(&#x27;https://api.uomg.com/api/rand.qinghua&#x27;,&#123; params:&#123;format:&#x27;json&#x27;&#125; &#125;).then((res)=&gt;&#123; console.log(res.data); &#125;) post 123456axios.post(&#x27;url&#x27;,&#123; username:&#x27;&#x27;, age:&#x27;&#x27;&#125;).then(()=&gt;&#123; &#125;) 挂载axios到Vue实例上 在main.js中通过原型挂载 123//引入axiosimport axios from &#x27;axios&#x27;Vue.prototype.$axios=axios 调用 1this.$axios.post() 利用Cli安装Vue项目 12npm i @vue/cli -gvue create 项目名 自定义安装，选择最后一项 选择2.0版本的vue(主流) 选择less进行样式预处理 配置文件的创建，选择第一项创建项目，如果项目创建慢，设置为淘宝镜像 npm run serve 启动项目 空格是选择安装的插件，回车则是确定选择项 项目构成 assets:存放静态资源，图片，css等内容 components:存放可以重用的组件 App.vue项目的跟组件 main.js程序入口文件 123456import App from &#x27;./App.vue&#x27;new Vue(&#123; render: h =&gt; h(App), //安装的插件可以在这里使用&#125;).$mount(&#x27;#app&#x27;)//这段代码表示，将App里面的内容渲染到index.html中 组件的data不能使用以前的对象写法，而是应该是一个函数，如下 12345data()&#123; return &#123; &#125;&#125; 组件方法 12345methods:&#123; change()&#123; this.msg=&#x27;芝士土拨鼠&#x27; &#125; &#125; 启用less h1{ background-color: pink; color: red; } 组件使用 使用import导入 12//@指的是src目录import Login from &#x27;@/components/Login.vue&#x27; 使用components节点注册 123components:&#123; Login&#125; 以标签形式使用 1&lt;Login&gt;&lt;/Login&gt; 全局注册组件 在main.js下面使用Vue.component(‘注册名称’,’组件名称’) 12import Right from &#x27;./components/Right.vue&#x27;Vue.component(&#x27;MyRight&#x27;,Right) 组件之间的数据共享 props 父组件向子组件传值 123456//子组件定义propsprops:[&#x27;message&#x27;]在子组件中使用propsthis.message//父组件通过标签传值&lt;Son :message=&quot;哈哈哈&quot;&gt;&lt;/Son&gt; 默认值（使用默认值定义props） 12345678910111213141516171819202122props:&#123; message:&#123; default:&#x27;hhh&#x27; &#125; &#125;, //type 值类型props:&#123; message:&#123; default:&#x27;hhh&#x27;,//Number，Boolean，String Object， Array等类型 type:String &#125; &#125;,//require必选 props:&#123; message:&#123; default:&#x27;hhh&#x27;, type:String, require:false &#125; &#125;, 子传父 需要在子组件中定义事件 123getName()&#123; this.$emit(&#x27;numChange&#x27;,&#x27;传递的值&#x27;)&#125; 父组件中 调用numChange方法 12345&lt;NewSon @numChange=&quot;getNewName&quot;&gt;&lt;/NewSon&gt;//将子组件传递过来的值接受并转存 getNewName(val)&#123; this.name=val &#125; 兄弟传值 样式冲突 给属性添加scoped属性，默认会给组件的所有标签添加一个自定义属性，不会影响到其他组件的样式 ![](F:\\Blog\\source\\imgs\\smzqi.png) beforeCreate:props，data，method还没创建，不能被使用 create：组件刚刚创建，props，data，method创建了，能被使用，模板尚未创建（dom结构尚未创建），常用发送请求 beforeMount： mounted：渲染DOM结构 beforeUpdate：数据发生变化时触发，但是不会改变DOM updated：已经是最新的数据和UI destroy：销毁阶段 DOM元素引用 this.$ref.xxx 12345&lt;h1 ref=&quot;myh1&quot;&gt;这是子组件&lt;/h1&gt;change()&#123; this.$refs.myh1.style.color=&#x27;red&#x27; &#125; #### this.$nextTick(callback) 延迟函数到下一次DOM结构更新再回调 12345//获取文本焦点 this.$nextTick(()=&gt;&#123; this.$refs.inpRef.focus() &#125;) 为什么不写在update中？因为每次数据更新都会触发update函数， 然而这里数据会更新两次，第二次更新 #### js处理数组的方法 forEach()遍历整个数组，不会停下 1234arr.forEach((item,index)=&gt;&#123; console.log(item); console.log(index); &#125;) some()遍历，不会遍历到低 123456arr.some((item)=&gt;&#123; console.log(item); if(item == &#x27;arr2&#x27;)&#123; return true; &#125; &#125;) every()判断每一项 12let flag= arr.every(item=&gt;item.state)console.log(flag); reduce累加方法，接受一个累加器和一个初始值，不断累加 1arr.reduce((item,total)=&gt;return total+=item.price,0) #### 动态组件 1&lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt; 动态获取comName,通过这种方式可以实现动态切换组件动态切换组件会销毁实例，可以使用keep-alive保持组件的存活 123&lt;keep-alive&gt; &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt; 这个组件会触发两个生命周期函数 deactivated:组件缓存 activated：激活时触发 指定组件缓存 ： include，多组件之间使用,分隔开 exclude=\"\"不缓存那些组件，不能同时使用 123&lt;keep-alive include=&quot;Son,Test&quot;&gt; &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt; #### 插槽 允许把用户不确定的内容定义为插槽，动态指定标签平时在自定义组件的html标签会被忽略，但是可以通过插槽的方式实现渲染 每个slot插槽建议定义一个名称 1&lt;slot :name=&quot;&quot;&gt;&lt;/slot&gt; 将内容填充到具体插槽中 123&lt;template v-slot:father&gt; &lt;p&gt;这是father组件的插槽&lt;/p&gt;&lt;/template&gt; v-slot简写 #，只能用在组件或者template组件上，如果不用这个属性，不需要template包裹 作用域插槽 在封装组件时，为预留的slot提供属性的插槽，就称为作用域插槽 12345678&lt;Father&gt; &lt;template #father=&quot;obj&quot;&gt; &lt;p&gt;这是father组件的插槽&lt;/p&gt; &#123;&#123; obj.msg&#125;&#125; &lt;/template&gt;&lt;/Father&gt;//插槽&lt;slot name=&quot;father&quot; msg=&quot;这是msg&quot;&gt;&lt;/slot&gt; #### 自定义指令 12345678910directives:&#123; //指令名称 color:&#123; //指令执行的函数 //binding对象有个value属性，就是指令上面传递的参数 color(el,binding)&#123; el.style.color=binding.value &#125; &#125;&#125; #### 全局自定义指令 12//使用全局自定义指令 Vue.directive(&#x27;color&#x27;,(el,binding)=&gt;&#123; el.style.color=binding.value &#125;) #### 路由 在地址中，#后面的属于hash地址。 路由就是hash地址和不同组件之间的对应关系。 **路由配置:** 编写配置文件，并导出实例 1234567891011import Vue from &#x27;vue&#x27;;import vueRouter from &#x27;vue-router&#x27;//使用路由Vue.use(vueRouter);//创建实例const router =new vueRouter();//向外共享一个router实例export default router **在main.js中使用** 123456import router from &#x27;@/router/index.js&#x27;new Vue(&#123; render: h =&gt; h(App), router&#125;).$mount(&#x27;#app&#x27;) **router-view组件** 起到占位符的作用，点击链接，链接内容展示在这个占位符里面，路由对应关系的编写， 编写路由与组件的对应关系 1234567891011121314//先导入组件，再使用//创建实例const router =new vueRouter(&#123; routes:[ &#123; path:&#x27;/right&#x27;, component:Right, &#125;, &#123; path:&#x27;/son&#x27;, component:Son, &#125; ]&#125;); 使用router-link代替a链接，可以不再使用#标识hash值 1&lt;router-link to=&quot;/right&quot;&gt;右组件&lt;/router-link&gt; 路由重定向(强制跳转) 12345&#123; path:&#x27;/&#x27;, redirect:&#x27;/login&#x27; &#125;, **嵌套路由** 1234567&#123; path:&#x27;/son&#x27;, component:Son, children:[ &#123;path:&#x27;/newson&#x27;, component:newSon&#125; ]&#125;, children里面那个子路由的path属性为空，则为默认子路由 **动态路由匹配** 123456//动态路由 &#123; //id值可以动态匹配到不同页面 path:&#x27;/movie/:id&#x27;, component:movie, &#125;, route对象 ![](F:\\Blog\\source\\imgs\\route.png) 发现传递的id值可以通过this.$route.params.id获取，query是路由中的?参数 #### 导航 声明式导航：通过标签实现跳转的 编程式导航：通过js代码实现跳转的 认识router对象，router是一个导航对象，提供一系列导航方法 this.$router.push()跳转到指定路径，并添加一条历史记录（history） this.$router.replace()跳转到指定路径，替换到当前地址 this.$router.go(数值n)在浏览历史中中前进或者后退，可以使用简化的方法forward和back方法 **导航守卫** ![](F:\\Blog\\source\\imgs\\router.png) 123456789101112//全局前置路由守卫//只要出现路由跳转，就会触发这个路由守卫的回调函数router.beforeEach((to,from,next)=&gt;&#123;//to:将要访问的路由//from: 即将离开的路由//next() 表示放行// console.log(from);// console.log(to);//next()函数的三种形式，next()放行，// next(false)强制停留在当前页面，next(&#x27;/login&#x27;)跳转到指定页面 next();&#125;) **模拟登录场景** 123456789101112131415161718//模拟登录场景//判断是否为login页，放行//首页需要登录//to from 都是一个route对象，里面的path值才是路由hash值 if(to.path === &#x27;/login&#x27;)&#123; next(); &#125; else&#123; //判断是否已经登录（token） //没有登录重定向到login页 //已经登录则放行 const token = localStorage.getItem(&#x27;token&#x27;); if(token)&#123; next(); &#125;else&#123; next(&#x27;/login&#x27;); &#125; &#125; **控制页面访问权限** 编写一个js文件保存需要控制的数组 导入数组判断是否在数组里面 js文件 12345export default [&#x27;/main&#x27;,&#x27;/movie&#x27;] //判断 if(pathArr.indexOf(to.path) === -1)&#123; next();&#125;` **路由控制进阶方案**（使用addRoute动态） [vue如何实现路由权限控制 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/55262808)动态创建路由","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"标签","slug":"tags","date":"2022-10-03T03:30:41.000Z","updated":"2022-10-03T04:15:18.977Z","comments":true,"path":"2022/10/03/tags/","link":"","permalink":"http://example.com/2022/10/03/tags/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-10-02T17:19:50.645Z","updated":"2022-10-03T07:07:31.039Z","comments":true,"path":"2022/10/03/hello-world/","link":"","permalink":"http://example.com/2022/10/03/hello-world/","excerpt":"Welcome to Hexo!","text":"Welcome to Hexo! Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Java8","slug":"Java8","permalink":"http://example.com/tags/Java8/"},{"name":"MySql","slug":"MySql","permalink":"http://example.com/tags/MySql/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}]}